#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# * Dockerfile.gen
#
# Generates a Dockerfile by using `Dockerfile.template` and the values
# for `ubuntu`, `rhel` or `dcar` distros.  It needs to be called with first
# argument being one of the supported distros.
#
# The result of the execution will be printed to stdout so it needs to
# be redirected into a Dockerfile.
#
# * Usage:
#
#     ../Dockerfile.gen [-h] [-d] image distro
#
# [-h]      help
# [-d]      enable debug mode for operator image
# <image>   can be any of: operator, database, appdb, opsmanager
# <distro>  can be any of: ubuntu, rhel, dcar
#
# It is required that the `Dockerfile.template` to exist in the
# current working directory.
#

from typing import Dict, List, Union, Callable
from pathlib import Path
import json
import os
import sys
import argparse

import jinja2


def get_version() -> str:
    """Returns the current version of the operator based on the
    release.json file. It find the release.json file in this directory
    and every parent directory up to the root.
    """
    def release(p: Path):
        if Path("/") == p:
            return

        if os.path.exists(os.path.join(p, "release.json")):
            return os.path.join(p, "release.json")
        else:
            return release(p.parent)

    release_path = release(Path(os.getcwd()))
    with open(release_path) as fd:
        release_json = json.loads(fd.read())
        return release_json["mongodbOperator"]


def ubuntu() -> Dict[str, Union[str, List[str]]]:
    """Ubuntu distro data (only for the Database image)"""
    # Note, that the Automation Agent needs lsb-release on the CLI to
    # determine the current distro
    version = get_version()

    return {
        "base_image": "ubuntu:16.04",
        "distro": "ubuntu",
        "version": version
    }


def rhel() -> Dict[str, Union[str, List[str]]]:
    """RHEL distro data (only for the Database image)"""
    return {
        "base_image": "registry.access.redhat.com/ubi7/ubi-minimal",
        "distro": "rhel",
        "version": get_version(),
    }


def dcar() -> Dict[str, Union[str, List[str]]]:
    """RHEL distro data (only for the Database image)"""
    # dcar release for disconnected network, avoid packages with epel
    # dependencies
    return {
        # base image is hardened ubi7 provided by dsop
        "base_image": "nexus-docker.52.61.140.4.nip.io/dsop/ubi7",
        "distro": "dcar",
        "local_repo": "nexus.52.61.140.4.nip.io/repository",
        "version": get_version(),
    }


def ops_manager(distro: Callable):
    """Renders an Ops Manager Dockerfile for a given distro."""
    params = distro()

    if params["base_image"].startswith("registry.access.redhat.com"):
        # We don't want ubi-minimal for Ops Manager, get the
        # full thing instead.
        params["base_image"] = "registry.access.redhat.com/ubi7/ubi"

    return params


def appdb(distro: Callable):
    params = distro()
    params["is_appdb"] = True

    return params


def operator(distro: Callable):
    return distro()


def database(distro: Callable):
    return distro()


def render(image_name: str, distro_name: str, **kwargs):
    """Renders a Dockerfile for a `image_type` on a `distro`."""
    distros = {
        "rhel": rhel,
        "ubuntu": ubuntu,
        "dcar": dcar,
    }

    image_types = {
        "opsmanager": ops_manager,
        "appdb": appdb,
        "operator": operator,
        "database": database,
    }

    if distro_name not in distros.keys():
        raise ValueError("{} is not a valid distro name.".format(distro_name))

    if image_name not in image_types.keys():
        raise ValueError("{} is not a valid  image type.".format(image_name))

    distro = distros[distro_name]
    image_type = image_types[image_name]

    template_params = image_type(distro)
    template_params.update(kwargs)

    env = jinja2.Environment()
    env.loader = jinja2.FileSystemLoader(".")

    return env.get_template(
        "Dockerfile.{}".format(distro_name)
    ).render(
        template_params
    )


def argument_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument("image", help="Type of image for the Dockerfile")
    parser.add_argument("distro", help="Distro this image should be based on")
    parser.add_argument("-d", "--debug", help="Builds a debuggable Operator image", action="store_true")
    return parser.parse_args()


def main() -> int:
    args = argument_parser()

    options = {}
    options["is_debug"] = args.debug

    print(render(args.image, args.distro, **options))

    return 0


if __name__ == "__main__":
    sys.exit(main())
