package construct

import (
	"fmt"

	"github.com/mongodb/mongodb-kubernetes-operator/pkg/util/merge"
	"go.uber.org/zap"

	mdbv1 "github.com/10gen/ops-manager-kubernetes/api/v1/mdb"
	"github.com/10gen/ops-manager-kubernetes/controllers/operator/certs"
	"github.com/10gen/ops-manager-kubernetes/controllers/operator/secrets"
	"github.com/10gen/ops-manager-kubernetes/pkg/kube"
	"github.com/10gen/ops-manager-kubernetes/pkg/vault"
	appsv1 "k8s.io/api/apps/v1"

	omv1 "github.com/10gen/ops-manager-kubernetes/api/v1/om"
	enterprisepem "github.com/10gen/ops-manager-kubernetes/controllers/operator/pem"
	"github.com/10gen/ops-manager-kubernetes/pkg/util"
	"github.com/10gen/ops-manager-kubernetes/pkg/util/env"
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/kube/container"
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/kube/lifecycle"
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/kube/podtemplatespec"
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/kube/probes"
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/kube/secret"
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/kube/statefulset"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

const (
	appLabelKey             = "app"
	podAntiAffinityLabelKey = "pod-anti-affinity"
)

func GetOpsManagerCAFileDir() string {
	return fmt.Sprintf("%s/certs/%s", MMSHome, "ops-manager-ca")
}

// OpsManagerStatefulSetOptions contains all of the different values that are variable between
// StatefulSets. Depending on which StatefulSet is being built, a number of these will be pre-set,
// while the remainder will be configurable via configuration functions which modify this type.
type OpsManagerStatefulSetOptions struct {
	OwnerReference               []metav1.OwnerReference
	HTTPSCertSecretName          string
	CertHash                     string
	AppDBTlsCAConfigMapName      string
	AppDBConnectionSecretName    string
	AppDBConnectionStringHash    string
	EnvVars                      []corev1.EnvVar
	Version                      string
	Name                         string
	Replicas                     int
	ServiceName                  string
	Namespace                    string
	OwnerName                    string
	ServicePort                  int
	OpsManagerCaName             string
	QueryableBackupPemSecretName string
	StatefulSetSpecOverride      *appsv1.StatefulSetSpec
	VaultConfig                  vault.VaultConfiguration
	Labels                       map[string]string
	// backup daemon only
	HeadDbPersistenceConfig *mdbv1.PersistenceConfig
}

func WithConnectionStringHash(hash string) func(opts *OpsManagerStatefulSetOptions) {
	return func(opts *OpsManagerStatefulSetOptions) {
		opts.AppDBConnectionStringHash = hash
	}
}

func WithVaultConfig(config vault.VaultConfiguration) func(opts *OpsManagerStatefulSetOptions) {
	return func(opts *OpsManagerStatefulSetOptions) {
		opts.VaultConfig = config
	}
}

// updateHTTPSCertSecret updates the fields for the OpsManager HTTPS certificate in case the provided secret is of type kubernetes.io/tls.
func (opts *OpsManagerStatefulSetOptions) updateHTTPSCertSecret(secretGetterCreattor secrets.SecretClient, ownerReferences []metav1.OwnerReference, log *zap.SugaredLogger) error {
	// Return immediately if no Certificate is provided
	if opts.HTTPSCertSecretName == "" {
		return nil
	}

	var err error
	var secretData map[string][]byte
	var s corev1.Secret
	var opsManagerSecretPath string

	if vault.IsVaultSecretBackend() {
		opsManagerSecretPath = secretGetterCreattor.VaultClient.OpsManagerSecretPath()
		secretData, err = secretGetterCreattor.VaultClient.ReadSecretBytes(fmt.Sprintf("%s/%s/%s", opsManagerSecretPath, opts.Namespace, opts.HTTPSCertSecretName))
		if err != nil {
			return err
		}
	} else {
		s, err = secretGetterCreattor.KubeClient.GetSecret(kube.ObjectKey(opts.Namespace, opts.HTTPSCertSecretName))
		if err != nil {
			return err
		}

		// SecretTypeTLS is kubernetes.io/tls
		// This is the standard way in K8S to have secrets that hold TLS certs
		// And it is the one generated by cert manager
		// These type of secrets contain tls.crt and tls.key entries
		if s.Type != corev1.SecretTypeTLS {
			return nil
		}
		secretData = s.Data
	}

	data, err := certs.VerifyTLSSecretForStatefulSet(secretData, certs.Options{})
	if err != nil {
		return err
	}

	certHash := enterprisepem.ReadHashFromSecret(secretGetterCreattor, opts.Namespace, opts.HTTPSCertSecretName, opsManagerSecretPath, log)

	// The operator concatenates the two fields of the secret into a PEM secret
	err = certs.CreatePEMSecretClient(secretGetterCreattor, kube.ObjectKey(opts.Namespace, opts.HTTPSCertSecretName), map[string]string{certHash: data}, ownerReferences, certs.OpsManager, log)
	if err != nil {
		return err
	}

	opts.HTTPSCertSecretName = fmt.Sprintf("%s%s", opts.HTTPSCertSecretName, certs.OperatorGeneratedCertSuffix)
	opts.CertHash = certHash

	return nil
}

// OpsManagerStatefulSet is the base method for building StatefulSet shared by Ops Manager and Backup Daemon.
// Shouldn't be called by end users directly
func OpsManagerStatefulSet(secretGetterCreator secrets.SecretClient, opsManager omv1.MongoDBOpsManager, log *zap.SugaredLogger, additionalOpts ...func(*OpsManagerStatefulSetOptions)) (appsv1.StatefulSet, error) {
	opts := opsManagerOptions(additionalOpts...)(opsManager)

	if err := opts.updateHTTPSCertSecret(secretGetterCreator, opsManager.OwnerReferences, log); err != nil {
		return appsv1.StatefulSet{}, err
	}

	secretName := opsManager.Spec.Backup.QueryableBackupSecretRef.Name
	opts.QueryableBackupPemSecretName = secretName
	if secretName != "" {
		// if the secret is specified, we must have a queryable.pem entry.
		_, err := secret.ReadKey(secretGetterCreator, "queryable.pem", kube.ObjectKey(opsManager.Namespace, secretName))
		if err != nil {
			return appsv1.StatefulSet{}, err
		}
	}

	omSts := statefulset.New(opsManagerStatefulSetFunc(opts))
	var err error
	if opts.StatefulSetSpecOverride != nil {
		omSts.Spec = merge.StatefulSetSpecs(omSts.Spec, *opts.StatefulSetSpecOverride)
	}

	// the JVM env args must be determined after any potential stateful set override
	// has taken place.
	if err = setJvmArgsEnvVars(opsManager.Spec, util.OpsManagerContainerName, &omSts); err != nil {
		return appsv1.StatefulSet{}, err
	}
	return omSts, nil

}

// getSharedOpsManagerOptions returns the options that are shared between both the OpsManager
// and BackupDaemon StatefulSets
func getSharedOpsManagerOptions(opsManager omv1.MongoDBOpsManager) OpsManagerStatefulSetOptions {

	return OpsManagerStatefulSetOptions{
		OwnerReference:          kube.BaseOwnerReference(&opsManager),
		OwnerName:               opsManager.Name,
		HTTPSCertSecretName:     opsManager.TLSCertificateSecretName(),
		AppDBTlsCAConfigMapName: opsManager.Spec.AppDB.GetCAConfigMapName(),
		EnvVars:                 opsManagerConfigurationToEnvVars(opsManager),
		Version:                 opsManager.Spec.Version,
		Namespace:               opsManager.Namespace,
		OpsManagerCaName:        opsManager.Spec.GetOpsManagerCA(),
		Labels:                  opsManager.Labels,
	}
}

// opsManagerOptions returns a function which returns the OpsManagerStatefulSetOptions to create the OpsManager StatefulSet
func opsManagerOptions(additionalOpts ...func(opts *OpsManagerStatefulSetOptions)) func(opsManager omv1.MongoDBOpsManager) OpsManagerStatefulSetOptions {
	return func(opsManager omv1.MongoDBOpsManager) OpsManagerStatefulSetOptions {
		var stsSpec *appsv1.StatefulSetSpec = nil
		if opsManager.Spec.StatefulSetConfiguration != nil {
			stsSpec = &opsManager.Spec.StatefulSetConfiguration.SpecWrapper.Spec
		}

		_, port := opsManager.GetSchemePort()

		opts := getSharedOpsManagerOptions(opsManager)
		opts.ServicePort = port
		opts.ServiceName = opsManager.SvcName()
		opts.Replicas = opsManager.Spec.Replicas
		opts.Name = opsManager.Name
		opts.StatefulSetSpecOverride = stsSpec
		opts.AppDBConnectionSecretName = opsManager.AppDBMongoConnectionStringSecretName()

		for _, additionalOpt := range additionalOpts {
			additionalOpt(&opts)
		}
		return opts
	}
}

// opsManagerStatefulSetFunc constructs the default Ops Manager StatefulSet modification function.
func opsManagerStatefulSetFunc(opts OpsManagerStatefulSetOptions) statefulset.Modification {

	postStart := func(lc *corev1.Lifecycle) {}
	caVolumeFunc := podtemplatespec.NOOP()
	caVolumeMountFunc := container.NOOP()
	if opts.AppDBTlsCAConfigMapName != "" {
		// It will add each X.509 public key certificate into JVM's trust store
		// with unique "mongodb_operator_added_trust_ca_$RANDOM" alias
		// See: https://jira.mongodb.org/browse/HELP-25872 for more details.

		postStart = func(lc *corev1.Lifecycle) {
			if lc.PostStart == nil {
				lc.PostStart = &corev1.LifecycleHandler{Exec: &corev1.ExecAction{}}
			}
			lc.PostStart.Exec.Command = []string{"/bin/sh", "-c", postStartScriptCmd()}
		}
	}

	return statefulset.Apply(
		backupAndOpsManagerSharedConfiguration(opts),
		statefulset.WithPodSpecTemplate(
			podtemplatespec.Apply(
				caVolumeFunc,
				// 5 minutes for Ops Manager just in case (its internal timeout is 20 seconds anyway)
				podtemplatespec.WithTerminationGracePeriodSeconds(300),
				podtemplatespec.WithContainerByIndex(0,
					container.Apply(
						caVolumeMountFunc,
						container.WithLifecycle(postStart),
						container.WithCommand([]string{"/opt/scripts/docker-entry-point.sh"}),
						container.WithName(util.OpsManagerContainerName),
						container.WithReadinessProbe(opsManagerReadinessProbe()),
						container.WithLifecycle(buildOpsManagerLifecycle()),
						container.WithEnvs(corev1.EnvVar{Name: "ENABLE_IRP", Value: "true"}),
					),
				),
			)),
	)
}

// backupAndOpsManagerSharedConfiguration returns a function which configures all of the shared
// options between the backup and Ops Manager StatefulSet
func backupAndOpsManagerSharedConfiguration(opts OpsManagerStatefulSetOptions) statefulset.Modification {
	managedSecurityContext, _ := env.ReadBool(util.ManagedSecurityContextEnv)
	omImageURL := fmt.Sprintf("%s:%s", env.ReadOrPanic(util.OpsManagerImageUrl), opts.Version)

	configurePodSpecSecurityContext := podtemplatespec.NOOP()
	if !managedSecurityContext {
		configurePodSpecSecurityContext = podtemplatespec.WithSecurityContext(podtemplatespec.DefaultPodSecurityContext())
	}

	pullSecretsConfigurationFunc := podtemplatespec.NOOP()
	if pullSecrets, ok := env.Read(util.ImagePullSecrets); ok {
		pullSecretsConfigurationFunc = podtemplatespec.WithImagePullSecrets(pullSecrets)
	}
	var omVolumeMounts []corev1.VolumeMount

	omScriptsVolume := statefulset.CreateVolumeFromEmptyDir("ops-manager-scripts")
	omVolumes := []corev1.Volume{omScriptsVolume}

	omScriptsVolumeMount := buildOmScriptsVolumeMount(true)
	omVolumeMounts = append(omVolumeMounts, omScriptsVolumeMount)

	vaultSecrets := vault.OpsManagerSecretsToInject{Config: opts.VaultConfig}
	if vault.IsVaultSecretBackend() {
		vaultSecrets.GenKeyPath = fmt.Sprintf("%s-gen-key", opts.OwnerName)
	} else {
		genKeyVolume := statefulset.CreateVolumeFromSecret("gen-key", fmt.Sprintf("%s-gen-key", opts.OwnerName))
		genKeyVolumeMount := corev1.VolumeMount{
			Name:      genKeyVolume.Name,
			ReadOnly:  true,
			MountPath: util.GenKeyPath,
		}
		omVolumeMounts = append(omVolumeMounts, genKeyVolumeMount)
		omVolumes = append(omVolumes, genKeyVolume)
	}

	if opts.QueryableBackupPemSecretName != "" {
		queryablePemVolume := statefulset.CreateVolumeFromSecret("queryable-pem", opts.QueryableBackupPemSecretName)
		omVolumeMounts = append(omVolumeMounts, corev1.VolumeMount{
			Name:      queryablePemVolume.Name,
			ReadOnly:  true,
			MountPath: "/certs/",
		})
		omVolumes = append(omVolumes, queryablePemVolume)
	}

	omHTTPSVolumeFunc := podtemplatespec.NOOP()

	if vault.IsVaultSecretBackend() {
		if opts.HTTPSCertSecretName != "" {
			vaultSecrets.TLSSecretName = opts.HTTPSCertSecretName
			vaultSecrets.TLSHash = opts.CertHash
		}
		vaultSecrets.AppDBConnection = opts.AppDBConnectionSecretName
		vaultSecrets.AppDBConnectionVolume = AppDBConnectionStringPath
	} else if opts.HTTPSCertSecretName != "" {

		omHTTPSCertificateVolume := statefulset.CreateVolumeFromSecret("om-https-certificate", opts.HTTPSCertSecretName)
		omHTTPSVolumeFunc = podtemplatespec.WithVolume(omHTTPSCertificateVolume)
		omVolumeMounts = append(omVolumeMounts, corev1.VolumeMount{
			Name:      omHTTPSCertificateVolume.Name,
			MountPath: util.MmsPemKeyFileDirInContainer,
		})

	}

	appDbTLSConfigMapVolumeFunc := podtemplatespec.NOOP()
	if opts.AppDBTlsCAConfigMapName != "" {
		appDbTLSVolume := statefulset.CreateVolumeFromConfigMap("appdb-ca-certificate", opts.AppDBTlsCAConfigMapName)
		appDbTLSConfigMapVolumeFunc = podtemplatespec.WithVolume(appDbTLSVolume)
		omVolumeMounts = append(omVolumeMounts, corev1.VolumeMount{
			Name:      appDbTLSVolume.Name,
			MountPath: util.AppDBMmsCaFileDirInContainer,
		})
	}

	podtemplateAnnotation := podtemplatespec.WithAnnotations(map[string]string{
		"connectionStringHash": opts.AppDBConnectionStringHash,
	})

	if vault.IsVaultSecretBackend() {
		podtemplateAnnotation = podtemplatespec.Apply(
			podtemplateAnnotation,
			podtemplatespec.WithAnnotations(
				vaultSecrets.OpsManagerAnnotations(opts.Namespace),
			),
		)
	}

	if !vault.IsVaultSecretBackend() {
		// configure the AppDB Connection String volume from a secret
		mmsMongoUriVolume, mmsMongoUriVolumeMount := buildMmsMongoUriVolume(opts)
		omVolumeMounts = append(omVolumeMounts, mmsMongoUriVolumeMount)
		omVolumes = append(omVolumes, mmsMongoUriVolume)
	}

	labels := defaultPodLabels(opts.ServiceName, opts.Name)

	// get the labels from the opts and append it to final labels
	stsLabels := defaultPodLabels(opts.ServiceName, opts.Name)
	for k, v := range opts.Labels {
		stsLabels[k] = v
	}

	return statefulset.Apply(
		statefulset.WithLabels(stsLabels),
		statefulset.WithMatchLabels(labels),
		statefulset.WithName(opts.Name),
		statefulset.WithNamespace(opts.Namespace),
		statefulset.WithOwnerReference(opts.OwnerReference),
		statefulset.WithReplicas(opts.Replicas),
		statefulset.WithServiceName(opts.ServiceName),
		statefulset.WithPodSpecTemplate(
			podtemplatespec.Apply(
				omHTTPSVolumeFunc,
				appDbTLSConfigMapVolumeFunc,
				podtemplateAnnotation,
				podtemplatespec.WithVolumes(omVolumes),
				configurePodSpecSecurityContext,
				podtemplatespec.WithPodLabels(labels),
				pullSecretsConfigurationFunc,
				podtemplatespec.WithServiceAccount(util.OpsManagerServiceAccount),
				podtemplatespec.WithAffinity(opts.Name, podAntiAffinityLabelKey, 100),
				podtemplatespec.WithTopologyKey(util.DefaultAntiAffinityTopologyKey, 0),
				podtemplatespec.WithInitContainerByIndex(0,
					buildOpsManagerAndBackupInitContainer(),
				),
				podtemplatespec.WithContainerByIndex(0,
					container.Apply(
						container.WithResourceRequirements(defaultOpsManagerResourceRequirements()),
						container.WithPorts(buildOpsManagerContainerPorts(opts.HTTPSCertSecretName)),
						container.WithImagePullPolicy(corev1.PullPolicy(env.ReadOrPanic(util.OpsManagerPullPolicy))),
						container.WithImage(omImageURL),
						container.WithEnvs(opts.EnvVars...),
						container.WithEnvs(getOpsManagerHTTPSEnvVars(opts.HTTPSCertSecretName, opts.CertHash)...),
						container.WithCommand([]string{"/opt/scripts/docker-entry-point.sh"}),
						container.WithVolumeMounts(omVolumeMounts),
					),
				),
			),
		),
	)
}

// opsManagerReadinessProbe creates the readiness probe.
// Note on 'PeriodSeconds': /monitor/health is a super lightweight method not doing any IO so we can make it more often.
func opsManagerReadinessProbe() probes.Modification {
	return probes.Apply(
		probes.WithInitialDelaySeconds(60),
		probes.WithTimeoutSeconds(5),
		probes.WithPeriodSeconds(5),
		probes.WithSuccessThreshold(1),
		probes.WithFailureThreshold(12),
		probes.WithHandler(corev1.ProbeHandler{
			HTTPGet: &corev1.HTTPGetAction{Scheme: corev1.URISchemeHTTP, Port: intstr.FromInt(8080), Path: "/monitor/health"},
		}),
	)
}

// buildOpsManagerAndBackupInitContainer creates the init container which
// copies the entry point script in the OM/Backup container
func buildOpsManagerAndBackupInitContainer() container.Modification {
	version := env.ReadOrDefault(util.InitOpsManagerVersion, "latest")
	initContainerImageURL := fmt.Sprintf("%s:%s", env.ReadOrPanic(util.InitOpsManagerImageUrl), version)

	return container.Apply(
		container.WithName(util.InitOpsManagerContainerName),
		container.WithImage(initContainerImageURL),
		container.WithVolumeMounts([]corev1.VolumeMount{buildOmScriptsVolumeMount(false)}),
	)
}

func buildOmScriptsVolumeMount(readOnly bool) corev1.VolumeMount {
	return corev1.VolumeMount{
		Name:      "ops-manager-scripts",
		MountPath: "/opt/scripts",
		ReadOnly:  readOnly,
	}
}

func buildOpsManagerLifecycle() lifecycle.Modification {
	return lifecycle.WithPrestopCommand([]string{"/bin/sh", "-c", "/mongodb-ops-manager/bin/mongodb-mms stop_mms"})
}

func getOpsManagerHTTPSEnvVars(httpsSecretName string, certHash string) []corev1.EnvVar {
	if httpsSecretName != "" {
		path := "server.pem"
		if certHash != "" {
			path = certHash
		}
		// Before creating the podTemplate, we need to add the new PemKeyFile
		// configuration if required.
		return []corev1.EnvVar{{
			Name:  omv1.ConvertNameToEnvVarFormat(util.MmsPEMKeyFile),
			Value: fmt.Sprintf("%s/%s", util.MmsPemKeyFileDirInContainer, path),
		}}
	}
	return []corev1.EnvVar{}
}

func defaultPodLabels(labelKey, antiAffinityKey string) map[string]string {
	return map[string]string{
		appLabelKey:             labelKey,
		ControllerLabelName:     util.OperatorName,
		podAntiAffinityLabelKey: antiAffinityKey,
	}
}

// defaultOpsManagerResourceRequirements returns the default ResourceRequirements
// which are used by OpsManager and the BackupDaemon
func defaultOpsManagerResourceRequirements() corev1.ResourceRequirements {
	defaultMemory, _ := resource.ParseQuantity(util.DefaultMemoryOpsManager)
	return corev1.ResourceRequirements{
		Limits: corev1.ResourceList{
			corev1.ResourceMemory: defaultMemory,
		},
		Requests: corev1.ResourceList{},
	}
}

func buildOpsManagerContainerPorts(httpsCertSecretName string) []corev1.ContainerPort {
	return []corev1.ContainerPort{{ContainerPort: int32(getOpsManagerContainerPort(httpsCertSecretName))}}
}

func getOpsManagerContainerPort(httpsSecretName string) int {
	_, port := omv1.SchemePortFromAnnotation("http")
	if httpsSecretName != "" {
		_, port = omv1.SchemePortFromAnnotation("https")
	}
	return port
}

// opsManagerConfigurationToEnvVars returns a list of corev1.EnvVar which should be passed
// to the container running Ops Manager
func opsManagerConfigurationToEnvVars(m omv1.MongoDBOpsManager) []corev1.EnvVar {
	var envVars []corev1.EnvVar
	for name, value := range m.Spec.Configuration {
		envVars = append(envVars, corev1.EnvVar{
			Name: omv1.ConvertNameToEnvVarFormat(name), Value: value,
		})
	}
	return envVars
}

// postStartScriptCmd returns a command to run as postStart.
//
// It adds each certificate into JVM trust store with a random alias.
func postStartScriptCmd() string {
	return fmt.Sprintf(
		`awk -v cmd="%s/jdk/bin/keytool -noprompt -storepass changeit -import -trustcacerts -alias mongodb_operator_added_trust_ca_${RANDOM} -keystore %s/jdk/lib/security/cacerts" '/BEGIN/{close(cmd)};{print | cmd}' 2>&1 < %s/ca-pem`, MMSHome, MMSHome, util.AppDBMmsCaFileDirInContainer,
	)
}
