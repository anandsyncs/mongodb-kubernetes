package certs

import (
	"fmt"
	"net/url"

	mdbv1 "github.com/10gen/ops-manager-kubernetes/api/v1/mdb"
	"github.com/hashicorp/go-multierror"

	"github.com/10gen/ops-manager-kubernetes/controllers/operator/secrets"
	"github.com/10gen/ops-manager-kubernetes/controllers/operator/workflow"
	"go.uber.org/zap"

	enterprisepem "github.com/10gen/ops-manager-kubernetes/controllers/operator/pem"
	"github.com/10gen/ops-manager-kubernetes/pkg/dns"
	"github.com/10gen/ops-manager-kubernetes/pkg/kube"
	"github.com/10gen/ops-manager-kubernetes/pkg/multicluster"
	"github.com/10gen/ops-manager-kubernetes/pkg/util"
	"github.com/10gen/ops-manager-kubernetes/pkg/vault"
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/kube/secret"
	corev1 "k8s.io/api/core/v1"

	"github.com/10gen/ops-manager-kubernetes/pkg/util/stringutil"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

type certDestination string

const (
	OperatorGeneratedCertSuffix = "-pem"
	CertHashAnnotationkey       = "certHash"

	Database   = "database"
	OpsManager = "opsmanager"
	AppDB      = "appdb"
)

// CreatePEMSecret creates a PEM secret from the original secretName.
func CreatePEMSecret(secretGetUpdater secret.GetUpdateCreator, secretNamespacedName types.NamespacedName, data map[string]string, ownerReferences []metav1.OwnerReference, log *zap.SugaredLogger) error {
	operatorGeneratedSecret := secretNamespacedName
	operatorGeneratedSecret.Name = fmt.Sprintf("%s%s", secretNamespacedName.Name, OperatorGeneratedCertSuffix)

	secretBuilder := secret.Builder().
		SetName(operatorGeneratedSecret.Name).
		SetNamespace(operatorGeneratedSecret.Namespace).
		SetOwnerReferences(ownerReferences)

	for k, v := range data {
		secretBuilder = secretBuilder.SetField(k, v)
	}

	return secret.CreateOrUpdateIfNeeded(secretGetUpdater, secretBuilder.Build())
}

// CreatePEMSecretClient creates a PEM secret from the original secretName.
func CreatePEMSecretClient(secretClient secrets.SecretClient, secretNamespacedName types.NamespacedName, data map[string]string, ownerReferences []metav1.OwnerReference, podType certDestination, log *zap.SugaredLogger) error {
	operatorGeneratedSecret := secretNamespacedName
	operatorGeneratedSecret.Name = fmt.Sprintf("%s%s", secretNamespacedName.Name, OperatorGeneratedCertSuffix)

	secretBuilder := secret.Builder().
		SetName(operatorGeneratedSecret.Name).
		SetNamespace(operatorGeneratedSecret.Namespace).
		SetOwnerReferences(ownerReferences)

	for k, v := range data {
		secretBuilder = secretBuilder.SetField(k, v)
	}

	var path string

	switch podType {
	case Database:
		path = vault.DatabaseSecretPath
	case OpsManager:
		path = vault.OpsManagerSecretPath
	case AppDB:
		path = vault.AppDBSecretPath
	default:
		return fmt.Errorf("unexpected pod type got: %s", podType)
	}
	return secretClient.PutSecretIfChanged(secretBuilder.Build(), path)
}

// VerifyTLSSecretForStatefulSet verifies a secret of type kubernetes.io/tls.
func VerifyTLSSecretForStatefulSet(secretData map[string][]byte, secretName string, opts Options) (string, error) {
	// Note that a kubernetes.io/tls secret HAS to have these two keys, by definition
	// We error check anyway but this should never happen
	crt, ok := secretData["tls.crt"]
	if !ok {
		return "", fmt.Errorf("Secret %s does not contain a tls.crt key", secretName)
	}

	key, ok := secretData["tls.key"]
	if !ok {
		return "", fmt.Errorf("Secret %s does not contain a tls.key key", secretName)
	}

	data := append(crt, key...)

	additionalDomains := []string{}
	for i := range getPodNames(opts) {
		additionalDomains = append(additionalDomains, GetAdditionalCertDomainsForMember(opts, i)...)
	}

	if err := validatePemData(data, additionalDomains); err != nil {
		return "", err
	}
	return string(data), nil
}

// VerifyAndEnsureCertificatesForStatefulSet ensures that the provided certificates are correct.
// If the secret is of type kubernetes.io/tls, it creates a new secret containing the concatenation fo the tls.crt and tls.key fields
func VerifyAndEnsureCertificatesForStatefulSet(secretsClient secrets.SecretClient, secretName string, opts Options, log *zap.SugaredLogger) (error, bool) {

	needToCreatePEM := false
	var err error
	var secretData map[string][]byte
	var s corev1.Secret

	if vault.IsVaultSecretBackend() {
		needToCreatePEM = true
		secretData, err = secretsClient.VaultClient.ReadSecretBytes(fmt.Sprintf("%s/%s/%s", vault.DatabaseSecretPath, opts.Namespace, secretName))
		if err != nil {
			return err, false
		}
	} else {
		s, err = secretsClient.KubeClient.GetSecret(kube.ObjectKey(opts.Namespace, secretName))
		if err != nil {
			return err, true
		}

		// SecretTypeTLS is kubernetes.io/tls
		// This is the standard way in K8S to have secrets that hold TLS certs
		// And it is the one generated by cert manager
		// These type of secrets contain tls.crt and tls.key entries
		if s.Type == corev1.SecretTypeTLS {
			needToCreatePEM = true
			secretData = s.Data
		}
	}

	if needToCreatePEM {
		data, err := VerifyTLSSecretForStatefulSet(secretData, s.Name, opts)
		var secretHash string
		if err != nil {
			return err, true
		}

		secretHash = enterprisepem.ReadHashFromSecret(secretsClient, opts.Namespace, secretName, vault.DatabaseSecretPath, log)
		return CreatePEMSecretClient(secretsClient, kube.ObjectKey(opts.Namespace, secretName), map[string]string{secretHash: data}, opts.OwnerReference, Database, log), true

	}

	var errs error

	// TODO Multi-cluster will be handled in a separate PR
	// For multi-cluster mode ....
	if opts.ClusterMode == multi {
		// get the pod names and get the service FQDN for each of the service hostnames
		mdbmName, clusterNum := multicluster.GetRsNamefromMultiStsName(opts.ResourceName), multicluster.MustGetClusterNumFromMultiStsName(opts.ResourceName)
		for podNum := 0; podNum < opts.Replicas; podNum++ {
			podName, serviceFQDN := dns.GetMultiPodName(mdbmName, clusterNum, podNum), dns.GetMultiServiceFQDN(mdbmName, opts.Namespace, clusterNum, podNum)
			pem := fmt.Sprintf("%s-pem", podName)
			if err := validatePemSecret(s, pem, []string{serviceFQDN}); err != nil {
				errs = multierror.Append(errs, err)
			}
		}

		return errs, false
	}

	for i, pod := range getPodNames(opts) {
		pem := fmt.Sprintf("%s-pem", pod)
		additionalDomains := GetAdditionalCertDomainsForMember(opts, i)
		if err := validatePemSecret(s, pem, additionalDomains); err != nil {
			errs = multierror.Append(errs, err)
		}
	}

	return errs, false
}

// getPodNames returns the pod names based on the Cert Options provided.
func getPodNames(opts Options) []string {
	_, podnames := dns.GetDNSNames(opts.ResourceName, opts.ServiceName, opts.Namespace, opts.ClusterDomain, opts.Replicas)
	return podnames
}

func GetDNSNames(opts Options) (hostnames, podnames []string) {
	return dns.GetDNSNames(opts.ResourceName, opts.ServiceName, opts.Namespace, opts.ClusterDomain, opts.Replicas)
}

// GetAdditionalCertDomainsForMember gets any additional domains that the
// certificate for the given member of the stateful set should be signed for.
func GetAdditionalCertDomainsForMember(opts Options, member int) (hostnames []string) {
	_, podnames := GetDNSNames(opts)
	for _, certDomain := range opts.additionalCertificateDomains {
		hostnames = append(hostnames, podnames[member]+"."+certDomain)
	}
	if len(opts.horizons) > 0 {
		//at this point len(ss.ReplicaSetHorizons) should be equal to the number
		//of members in the replica set
		for _, externalHost := range opts.horizons[member] {
			//need to use the URL struct directly instead of url.Parse as
			//Parse expects the URL to have a scheme.
			hostURL := url.URL{Host: externalHost}
			hostnames = append(hostnames, hostURL.Hostname())
		}
	}
	return hostnames
}

func validatePemData(data []byte, additionalDomains []string) error {
	pemFile := enterprisepem.NewFileFromData(data)
	if !pemFile.IsComplete() {
		return fmt.Errorf("the certificate is not complete\n")
	}

	cert, err := pemFile.ParseCertificate()
	if err != nil {
		return fmt.Errorf("can't parse certificate: %s\n", err)
	}

	for _, domain := range additionalDomains {
		if !stringutil.CheckCertificateAddresses(cert.DNSNames, domain) {
			return fmt.Errorf("domain %s is not contained in the list of DNSNames %v\n", domain, cert.DNSNames)
		}
	}
	return nil
}

// validatePemSecret returns true if the given Secret contains a parsable certificate and contains all required domains.
func validatePemSecret(secret corev1.Secret, key string, additionalDomains []string) error {
	data, ok := secret.Data[key]
	if !ok {
		return fmt.Errorf("the secret %s does not contain the expected key %s\n", secret.Name, key)
	}

	return validatePemData(data, additionalDomains)
}

// ValidateCertificates verifies the Secret containing the certificates and the keys is valid.
func ValidateCertificates(secretGetter secret.Getter, name, namespace string) error {
	byteData, err := secret.ReadByteData(secretGetter, kube.ObjectKey(namespace, name))
	if err == nil {
		// Validate that the secret contains the keys, if it contains the certs.
		for _, value := range byteData {
			pemFile := enterprisepem.NewFileFromData(value)
			if !pemFile.IsValid() {
				return fmt.Errorf(fmt.Sprintf("The Secret %s containing certificates is not valid. Entries must contain a certificate and a private key.", name))
			}
		}
	}
	return nil
}

// VerifyAndEnsureClientCertificatesForAgentsAndTLSType ensures that agent certs are present and correct, and returns whether or not they are of the kubernetes.io/tls type.
// If the secret is of type kubernetes.io/tls, it creates a new secret containing the concatenation fo the tls.crt and tls.key fields
func VerifyAndEnsureClientCertificatesForAgentsAndTLSType(secretsClient secrets.SecretClient, secret types.NamespacedName, log *zap.SugaredLogger) (error, bool) {

	needToCreatePEM := false
	var secretData map[string][]byte
	var s corev1.Secret
	var err error

	if vault.IsVaultSecretBackend() {
		needToCreatePEM = true
		secretData, err = secretsClient.VaultClient.ReadSecretBytes(fmt.Sprintf("%s/%s/%s", vault.DatabaseSecretPath, secret.Namespace, secret.Name))
		if err != nil {
			return err, false
		}
	} else {
		s, err = secretsClient.KubeClient.GetSecret(secret)
		if err != nil {
			return err, true
		}

		if s.Type == corev1.SecretTypeTLS {
			needToCreatePEM = true
			secretData = s.Data
		}
	}
	if needToCreatePEM {
		data, err := VerifyTLSSecretForStatefulSet(secretData, secret.Name, Options{Replicas: 0})
		if err != nil {
			return err, false
		}
		dataMap := map[string]string{
			util.AutomationAgentPemSecretKey: data,
		}
		return CreatePEMSecretClient(secretsClient, secret, dataMap, []metav1.OwnerReference{}, Database, log), true
	}

	additionalDomains := []string{} // agents have no additional domains
	return validatePemSecret(s, util.AutomationAgentPemSecretKey, additionalDomains), false
}

// EnsureSSLCertsForStatefulSet contains logic to ensure that all of the
// required SSL certs for a StatefulSet object exist.
// It also returns a boolean value indicating whether or no the new tls design must be used
func EnsureSSLCertsForStatefulSet(secretClient secrets.SecretClient, ms mdbv1.Security, opts Options, log *zap.SugaredLogger) (workflow.Status, bool) {

	if !ms.IsTLSEnabled() {
		// if there's no SSL certs to generate, return
		// Note that we return true, so that enabling TLS later won't cause restarts
		return workflow.OK(), true
	}

	secretName := opts.CertSecretName
	if !ms.TLSConfig.IsSelfManaged() {
		return workflow.Failed("Operator-generated certs are not supported. You must create your own certificates."), true
	}
	return ValidateSelfManagedSSLCertsForStatefulSet(secretClient, secretName, opts, log)

}

// ValidateSelfManagedSSLCertsForStatefulSet ensures that a stateful set using
// user-provided certificates has all of the relevant certificates in place.
// It also returns a boolean value indicating whether or no the new tls design must be used
func ValidateSelfManagedSSLCertsForStatefulSet(secretClient secrets.SecretClient, secretName string, opts Options, log *zap.SugaredLogger) (workflow.Status, bool) {
	// A "Certs" attribute has been provided
	// This means that the customer has provided with a secret name they have
	// already populated with the certs and keys for this deployment.
	// Because of the async nature of Kubernetes, this object might not be ready yet,
	// in which case, we'll keep reconciling until the object is created and is correct.
	err, newTlsDesign := VerifyAndEnsureCertificatesForStatefulSet(secretClient, secretName, opts, log)
	if err != nil {
		return workflow.Failed("The secret object '%s' does not contain all the valid certificates needed: %s", secretName, err), true
	}

	if newTlsDesign {
		secretName = fmt.Sprintf("%s-pem", secretName)
	}
	if err := ValidateCertificates(secretClient.KubeClient, secretName, opts.Namespace); err != nil {
		return workflow.Failed(err.Error()), true
	}

	return workflow.OK(), newTlsDesign
}
