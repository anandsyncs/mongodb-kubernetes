#!/usr/bin/env bash

set -Eeou pipefail

ensure_test_namespace(){
    local context=${1}
    kubectl create ns --context "${context}"  "${PROJECT_NAMESPACE}"  &>/dev/null  || true
    kubectl label ns "${PROJECT_NAMESPACE}" --context "${context}" "evg=task" &>/dev/null || true
    # shellcheck disable=SC2154
    kubectl annotate ns "${PROJECT_NAMESPACE}" --context "${context}" "evg/task=https://evergreen.mongodb.com/task/${task_id:-}" &>/dev/null || true
}

get_test_namespaces() {
  local context=${1}
  kubectl get namespaces --context "${context}" --selector=evg=task -o jsonpath='{.items[*].metadata.name}'
}

create_service_account_token_secret() {
  context=$1
  service_account_name=$2
  secret_name=$3
  kubectl --context "${context}" apply -n "${PROJECT_NAMESPACE}" -f - <<EOF
    apiVersion: v1
    kind: Secret
    metadata:
      name: ${secret_name}
      annotations:
        kubernetes.io/service-account.name: ${service_account_name}
    type: kubernetes.io/service-account-token
EOF

}

configure_multi_cluster_environment(){
    echo "Running a multi cluster test, configuring e2e roles in all clusters and kubeconfig secret."

    if [[ "${CLUSTER_TYPE}" == "kind" ]]; then
      echo "Overriding api_servers in kubeconfig to node addresses accessible from pods"
      kind_kubeconfig=$(mktemp)
      cp "${KUBECONFIG}" "${kind_kubeconfig}"
      local idx=1
      for member_cluster in ${member_clusters}; do
        api_server_url="https://$(kubectl get svc --context "${member_cluster}" -n default kubernetes -o=jsonpath='{.spec.clusterIP}')"
        echo "Overriding in ${kind_kubeconfig} api_server for ${member_cluster} with node address: ${api_server_url}"
        kubectl config --kubeconfig "${kind_kubeconfig}" set "clusters.${member_cluster}.server" "${api_server_url}"
        ((idx++))
      done
      # shellcheck disable=SC2154
      api_server_url="https://$(kubectl get svc --context "${central_cluster}" -n default kubernetes -o=jsonpath='{.spec.clusterIP}')"
      echo "Overriding in ${kind_kubeconfig} api_server for ${central_cluster} with node address: ${api_server_url}"
      kubectl config --kubeconfig "${kind_kubeconfig}" set "clusters.${central_cluster}.server" "${api_server_url}"
    fi

    echo "Ensuring namespaces"
    # shellcheck disable=SC2154
    ensure_test_namespace "${central_cluster}"
     # shellcheck disable=SC2154
    for member_cluster in ${member_clusters}; do
      ensure_test_namespace "${member_cluster}"
      kubectl --context "${member_cluster}" label ns "${PROJECT_NAMESPACE}" istio-injection=enabled --overwrite
      # configure mtls at the namespace level.
      if [[ -z "${local:-}" ]]; then
        kubectl --context "${member_cluster}"  -n "${PROJECT_NAMESPACE}" apply -f - <<EOF
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: "default"
spec:
  mtls:
    mode: STRICT
EOF
      fi
    done

    helm_template_file=$(mktemp)

    params=(
        "--set" "namespace=${PROJECT_NAMESPACE}"
        "--set" "imagePullSecrets=image-registries-secret"
    )

    helm template "scripts/evergreen/deployments/multi-cluster-roles" "${params[@]}" > "${helm_template_file}" || exit 1


    echo "Creating KubeConfig secret for test pod in namespace ${PROJECT_NAMESPACE}}"
    secret_kubeconfig=${KUBECONFIG}
    if [[ "${CLUSTER_TYPE}" == "kind" ]]; then
      secret_kubeconfig=${kind_kubeconfig}
      echo "Using temporary kubeconfig with changed api servers: ${secret_kubeconfig}"
    fi
    # shellcheck disable=SC2154
    kubectl --context "${test_pod_cluster}" delete secret test-pod-kubeconfig  -n "${PROJECT_NAMESPACE}" --ignore-not-found
    kubectl --context "${test_pod_cluster}" create secret generic test-pod-kubeconfig --from-file=kubeconfig="${secret_kubeconfig}" --namespace "${PROJECT_NAMESPACE}" || true

    echo "Creating project configmap"
    # delete `my-project` if it exists
    kubectl --context "${central_cluster}" --namespace "${PROJECT_NAMESPACE}" delete configmap my-project --ignore-not-found
    # Configuring project
    kubectl --context "${central_cluster}" --namespace "${PROJECT_NAMESPACE}" create configmap my-project \
            --from-literal=projectName="${PROJECT_NAMESPACE}" --from-literal=baseUrl="${OM_BASE_URL}" \
            --from-literal=orgId="${OM_ORGID:-}"

    echo "Creating/updating pull secret from docker configured file"
    kubectl -n "${PROJECT_NAMESPACE}" delete secret image-registries-secret --ignore-not-found
    kubectl --context "${central_cluster}" -n "${PROJECT_NAMESPACE}" create secret generic image-registries-secret \
     --from-file=.dockerconfigjson="${HOME}/.docker/config.json" --type=kubernetes.io/dockerconfigjson
    for member_cluster in ${member_clusters}; do
      kubectl --context "${member_cluster}" -n "${PROJECT_NAMESPACE}" delete secret image-registries-secret --ignore-not-found
      kubectl --context "${member_cluster}" -n "${PROJECT_NAMESPACE}" create secret generic image-registries-secret \
     --from-file=.dockerconfigjson="${HOME}/.docker/config.json" --type=kubernetes.io/dockerconfigjson
    done

    echo "Creating credentials secret"
    # delete `my-credentials` if it exists
    kubectl --context "${central_cluster}" --namespace "${PROJECT_NAMESPACE}" delete  secret my-credentials  --ignore-not-found
    # Configure the Kubernetes credentials for Ops Manager
    kubectl --context "${central_cluster}" --namespace "${PROJECT_NAMESPACE}" create secret generic my-credentials \
            --from-literal=user="${OM_USER:=admin}" --from-literal=publicApiKey="${OM_API_KEY}"

    echo "Creating required roles and service accounts."
    kubectl --context "${central_cluster}" -n "${PROJECT_NAMESPACE}" apply -f "${helm_template_file}"
    for member_cluster in ${member_clusters}; do
      kubectl --context "${member_cluster}" -n "${PROJECT_NAMESPACE}" apply -f "${helm_template_file}"
    done

    rm "${helm_template_file}"
    # wait some time for service account token secrets to appear.
    sleep 1

    local service_account_name="operator-tests-multi-cluster-service-account"

    local secret_name
    secret_name="$(kubectl --context  "${central_cluster}" get secret -n "${PROJECT_NAMESPACE}" | { grep "${service_account_name}" || test $? = 1; } | awk '{ print $1 }')"
    if [[ "${secret_name}" == "" ]]; then
      secret_name="${service_account_name}-token-secret"
      create_service_account_token_secret "${central_cluster}" "${service_account_name}" "${secret_name}"
    fi

    local central_cluster_token
    central_cluster_token="$(kubectl --context "${central_cluster}" get secret "${secret_name}" -o jsonpath='{ .data.token}' -n "${PROJECT_NAMESPACE}" | base64 -d)"
    echo "Creating Multi Cluster configuration secret"

    configuration_params=(
      "--from-literal=central_cluster=${central_cluster}"
    )

    configuration_params+=(
      "--from-literal=${central_cluster}=${central_cluster_token}"
    )

    INDEX=1
    for member_cluster in ${member_clusters}; do
      secret_name="$(kubectl --context  "${member_cluster}" get secret -n "${PROJECT_NAMESPACE}" | { grep "${service_account_name}" || test $? = 1; }  | awk '{ print $1 }')"
      if [[ "${secret_name}" == "" ]]; then
        secret_name="${service_account_name}-token-secret"
        create_service_account_token_secret "${member_cluster}" "${service_account_name}" "${secret_name}"
      fi

      member_cluster_token="$(kubectl --context "${member_cluster}" get secret "${secret_name}" -o jsonpath='{ .data.token}' -n "${PROJECT_NAMESPACE}" | base64 -d)"
      # for 2 cluster tests central cluster is the first member, so we cannot add this as it will result in duplicate key and error in create secret
      if [[ "${member_cluster}" != "${central_cluster}" ]]; then
        configuration_params+=(
           "--from-literal=${member_cluster}=${member_cluster_token}"
        )
      fi
      configuration_params+=(
         "--from-literal=member_cluster_${INDEX}=${member_cluster}"
      )
      (( INDEX++ ))
    done

    if [[ -f "${kind_kubeconfig}" ]]; then
      rm "${kind_kubeconfig}"
    fi

    kubectl --context "${test_pod_cluster}" delete secret test-pod-multi-cluster-config -n "${PROJECT_NAMESPACE}" --ignore-not-found
    kubectl --context "${test_pod_cluster}" create secret generic test-pod-multi-cluster-config -n "${PROJECT_NAMESPACE}" "${configuration_params[@]}"
}

prepare_multi_cluster_e2e_run() {
  # shellcheck disable=SC2034
  operator_context="${central_cluster}"
  configure_multi_cluster_environment

  if [[ "$(uname)" == "Darwin" ]]; then
    goarch="amd64"
    if [[ "$(uname -m)" == "arm64" ]]; then
      goarch="arm64"
    fi

    (cd public/tools/multicluster/; GOOS=darwin GOARCH="${goarch}" go build -o "${MULTI_CLUSTER_KUBE_CONFIG_CREATOR_PATH}" main.go)
    PATH=$PATH:docker/mongodb-enterprise-tests
  fi

  test_pod_secret_name="test-pod-multi-cluster-config"
  echo "Creating local configuration for multi cluster test in ${MULTI_CLUSTER_CONFIG_DIR}"
  mkdir -p "${MULTI_CLUSTER_CONFIG_DIR}"

  # escape "." sign from cluster names
  # shellcheck disable=SC2001,SC2086
  central_cluster_escaped=$(echo $central_cluster | sed 's/\./\\./g')
  # shellcheck disable=SC2206
  member_cluster_list=($member_clusters)
  # shellcheck disable=SC2001,SC2086
  member_cluster_1_escaped=$(echo  ${member_cluster_list[0]} | sed 's/\./\\./g')
  # shellcheck disable=SC2001,SC2086
  member_cluster_2_escaped=$(echo  ${member_cluster_list[1]} | sed 's/\./\\./g')
  # shellcheck disable=SC2001,SC2086
  member_cluster_3_escaped=$(echo  ${member_cluster_list[2]} | sed 's/\./\\./g')

  kubectl --context "${test_pod_cluster}" get secret "${test_pod_secret_name}" -n "${PROJECT_NAMESPACE}" -o jsonpath="{ .data.central_cluster }" | base64 -d > "${MULTI_CLUSTER_CONFIG_DIR}/central_cluster"
  kubectl --context "${test_pod_cluster}" get secret "${test_pod_secret_name}" -n "${PROJECT_NAMESPACE}" -o jsonpath="{ .data.${central_cluster_escaped} }" | base64 -d > "${MULTI_CLUSTER_CONFIG_DIR}/${central_cluster}"

  kubectl --context "${test_pod_cluster}" get secret "${test_pod_secret_name}" -n "${PROJECT_NAMESPACE}" -o jsonpath="{ .data.member_cluster_1 }" | base64 -d > "${MULTI_CLUSTER_CONFIG_DIR}/member_cluster_1"
  kubectl --context "${test_pod_cluster}" get secret "${test_pod_secret_name}" -n "${PROJECT_NAMESPACE}" -o jsonpath="{ .data.${member_cluster_1_escaped} }" | base64 -d > "${MULTI_CLUSTER_CONFIG_DIR}/${member_cluster_list[0]}"

  kubectl --context "${test_pod_cluster}" get secret "${test_pod_secret_name}" -n "${PROJECT_NAMESPACE}" -o jsonpath="{ .data.member_cluster_2 }" | base64 -d > "${MULTI_CLUSTER_CONFIG_DIR}/member_cluster_2"
  kubectl --context "${test_pod_cluster}" get secret "${test_pod_secret_name}" -n "${PROJECT_NAMESPACE}" -o jsonpath="{ .data.${member_cluster_2_escaped} }" | base64 -d > "${MULTI_CLUSTER_CONFIG_DIR}/${member_cluster_list[1]}"

  kubectl --context "${test_pod_cluster}" get secret "${test_pod_secret_name}" -n "${PROJECT_NAMESPACE}" -o jsonpath="{ .data.member_cluster_3 }" | base64 -d > "${MULTI_CLUSTER_CONFIG_DIR}/member_cluster_3"
  kubectl --context "${test_pod_cluster}" get secret "${test_pod_secret_name}" -n "${PROJECT_NAMESPACE}" -o jsonpath="{ .data.${member_cluster_3_escaped} }" | base64 -d > "${MULTI_CLUSTER_CONFIG_DIR}/${member_cluster_list[2]}"
}

run_multi_cluster_kube_config_creator() {
  if [[ "${LOCAL_OPERATOR}" != "true" ]]; then
    return
  fi

  # shellcheck disable=SC2153
  # convert space separated to comma separated
  member_clusters=$(echo -n "${MEMBER_CLUSTERS}" | xargs | sed "s/ /,/g")

  params=(
    "-member-clusters" "${member_clusters}"
    "-central-cluster" "${CENTRAL_CLUSTER}"
    "-member-cluster-namespace" "${NAMESPACE}"
    "-central-cluster-namespace" "${NAMESPACE}"
    "-service-account" "mongodb-enterprise-operator-multi-cluster"
  )

  if [[ "${OPERATOR_CLUSTER_SCOPED}" == "true" ]]; then
    params+=("-cluster-scoped")
  fi
  if [[ "${MULTI_CLUSTER_CREATE_SERVICE_ACCOUNT_TOKEN_SECRETS}" == "true" ]]; then
    params+=("-create-service-account-secrets")
  fi

  ${MULTI_CLUSTER_KUBE_CONFIG_CREATOR_PATH} setup "${params[@]}"

  kubectl get secret -n "${NAMESPACE}" mongodb-enterprise-operator-multi-cluster-kubeconfig -o json | jq -rc '.data.kubeconfig' | base64 -d > "${KUBE_CONFIG_PATH}"
}
