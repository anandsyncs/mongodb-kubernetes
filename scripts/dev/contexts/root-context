#!/bin/bash

set -Eeou pipefail

script_name=$(readlink -f "${BASH_SOURCE[0]}")
script_dir=$(dirname "${script_name}")

source "$script_dir/private-context"

export PROJECT_DIR="$PWD"
export IMAGE_TYPE=ubi
export UBI_IMAGE_WITHOUT_SUFFIX=true
export WATCH_NAMESPACE=${WATCH_NAMESPACE:-$NAMESPACE}

#
# changing variables below should not be necessary
#

# these are fixed when using scripts/dev/recreate_kind_clusters.sh
export TEST_POD_CLUSTER="$CLUSTER_NAME"

export CENTRAL_CLUSTER="${CLUSTER_NAME}"
export MULTI_CLUSTER_CREATE_SERVICE_ACCOUNT_TOKEN_SECRETS=true
export MULTI_CLUSTER_CONFIG_DIR=${PROJECT_DIR}/.multi_cluster_local_test_files
export MULTI_CLUSTER_KUBE_CONFIG_CREATOR_PATH=${PROJECT_DIR}/docker/mongodb-enterprise-tests/multi-cluster-kube-config-creator

# override for /etc/config/kubeconfig file mounted in operator's pod
if [[ "${LOCAL_OPERATOR}" == "true" ]]; then
  # This env var is used by the local operator to load multi-cluster kubeconfig.
  # Normally, the pod is loading it from a path that is mounted from the mongodb-enterprise-operator-multi-cluster-kubeconfig secret.
  # When running locally, we use cli tool to generate that kubeconfig secret and write it to this file.
  # This way, the local operator is using kubeconfig create by cli tool the same way as it's used when running in a pod.
  export KUBE_CONFIG_PATH=~/.operator-dev/multicluster_kubeconfig
  export PERFORM_FAILOVER=false
fi

export OPERATOR_ENV=${OPERATOR_ENV:-"dev"}

export AGENT_VERSION=12.0.30.7791-1

# Ops Manager
export OPS_MANAGER_NAMESPACE="operator-testing-50-current"

# Moved from the old set_env_context.sh
export LOCAL_RUN=true
# version_id is similar to version_id from Evergreen. Used to differentiate different builds. Can be constant
# for local run
version_id=${version_id:-"latest"}
if [[ "${OVERRIDE_VERSION_ID:-}" != "" ]]; then
  version_id="${OVERRIDE_VERSION_ID}"
fi
export version_id
export VERSION_ID="$version_id"

export INIT_APPDB_VERSION="$VERSION_ID"
export INIT_DATABASE_VERSION="$VERSION_ID"
export INIT_OPS_MANAGER_VERSION="$VERSION_ID"
export DATABASE_VERSION="$VERSION_ID"

export KUBE_ENVIRONMENT_NAME=kind

# when using EVG ec2 instance, we copy kubeconfig locally and use it
if [[ "${EVG_HOST_NAME:-}" != "" ]]; then
  KUBECONFIG=~/.operator-dev/evg-host.kubeconfig
else
  KUBECONFIG=~/.kube/config
fi
export KUBECONFIG
# Passed by the switch_context.sh
export CONTEXT="${context:-"unknown"}"

if [[ "$(uname)" == "Linux" ]]; then
  export GOROOT=/opt/golang/go1.21
fi

export MONGODB_REPO_URL="quay.io/mongodb"

export CLUSTER_DOMAIN="cluster.local"