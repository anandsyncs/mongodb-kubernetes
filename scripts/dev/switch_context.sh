#!/usr/bin/env bash

set -Eeou pipefail
# script prepares environment variables relevant for the current context

source scripts/funcs/errors

script_name=$(readlink -f "${BASH_SOURCE[0]}")
script_dir=$(dirname "${script_name}")

destination_envs_dir="$script_dir/../../.generated"
destination_envs_file="$destination_envs_dir/context"

context="$1"
context_file="scripts/dev/contexts/${context}"

mkdir -p "$destination_envs_dir"

if [[ ! -f "${context_file}" ]]; then
	fatal "Cannot switch context: File ${context_file} does not exist."
fi

echo "Switching context to: ${context}"

# shellcheck disable=SC2207
previous_envs=($(env | sed 's/ /;/g'))
# shellcheck disable=SC1090
source "${context_file}"

# This means we are running on evergreen, in this case we need the environment variables from evg expansions.
# If running locally, we don't need them since they are defined in the private-context already, so we don't need
# any kind of current env var expansions
if [ -n "${EVR_TASK_ID-}" ]; then
  # shellcheck disable=SC2207
  current_envs=$(env | sed 's/ /;/g')
  added_envs=$(echo "${previous_envs[@]}" "${current_envs[@]}" | sed 's/ /\n/g' | sort | uniq -u | sed 's/;/ /g' | sed 's/=/="/;s/$/"/')
else
  # env -i makes sure to start the shell with an empty shell, such that we only save into context.env the env vars we have
  # defined.
  current_envs=$(env -i bash -c "source ${context_file} && env")
  added_envs=$(echo "${current_envs[@]}" | sort | sed 's/;/ /g' | sed 's/=/="/;s/$/"/')
fi


echo -e "## This file is automatically generated by switch_context.sh\n## Do not edit it!" > "${destination_envs_file}.env"
# shellcheck disable=SC2129
echo -e "## Regenerated at $(date)\n" >> "${destination_envs_file}.env"
echo "$added_envs" >> "${destination_envs_file}.env"
# Below is a list of special cases of variables that are called the same in EVG and local context.
# This piece should probably be refactored as it's super easy to make a mistake and shadow the proper variable.
echo "workdir=\"${workdir:-.}\"" >> "${destination_envs_file}.env"

# We need to tail +5 lines due to above generated comment.
awk '{print "export " $0}' < "${destination_envs_file}".env | tail -n +5 > "${destination_envs_file}".export.env

scripts/dev/print_operator_env.sh | sort | uniq >"${destination_envs_file}.operator.env"
awk '{print "export " $0}' < "${destination_envs_file}".operator.env > "${destination_envs_file}".operator.export.env

echo "Generated env files in $(readlink -f "$destination_envs_dir"):"
ls -l1 "$destination_envs_dir"

if which kubectl > /dev/null; then
    if [ "${CLUSTER_NAME-}" ]; then
        # The convention: the cluster name must match the name of kubectl context
        # We expect this not to be true if kubernetes cluster is still to be created (minikube/kops)
        if ! kubectl config use-context "${CLUSTER_NAME}"; then
            echo "Warning: failed to switch kubectl context to: ${CLUSTER_NAME}"
            echo "Does a matching Kubernetes context exist?"
        fi

        # Setting the default namespace for current context
        kubectl config set-context "$(kubectl config current-context)" "--namespace=${NAMESPACE}" &>/dev/null || true

        # shellcheck disable=SC2153
        echo "Current context: ${CONTEXT} (kubectl context: ${CLUSTER_NAME}), namespace=${NAMESPACE}"
    fi
else
    echo "Kubectl doesn't exist, skipping setting the context"
fi

