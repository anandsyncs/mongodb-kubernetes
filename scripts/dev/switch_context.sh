#!/usr/bin/env bash

set -Eeou pipefail
# script prepares environment variables relevant for the current context

source scripts/funcs/errors

script_name=$(readlink -f "${BASH_SOURCE[0]}")
script_dir=$(dirname "${script_name}")

destination_envs_dir="$script_dir/../../.generated"
destination_envs_file="$destination_envs_dir/context"

context="$1"
additional_override="${2:-}"

context_file="scripts/dev/contexts/${context}"
override_context_file="scripts/dev/contexts/private-context-override"
additional_override_file="scripts/dev/contexts/private-context-${additional_override}"

mkdir -p "$destination_envs_dir"

if [[ ! -f "${context_file}" ]]; then
	fatal "Cannot switch context: File ${context_file} does not exist."
fi

echo "Switching context to: ${context}"

# shellcheck disable=SC1090
source "${context_file}"

# This means we are running on evergreen, in this case we need the environment variables from evg expansions.
# If running locally, we don't need them since they are defined in the private-context already, so we don't need
# any kind of current env var expansions
if [ -n "${EVR_TASK_ID-}" ]; then
  # shellcheck disable=SC2207
  current_envs=$(env)
else
  # env -i makes sure to start the shell with an empty shell, such that we only save into context.env the env vars we have
  # defined.
  if [ -n "$additional_override" ]; then
      echo "Using additional override file: $additional_override_file."
      current_envs=$(env -i bash -c "source ${context_file} && source ${additional_override_file} && env")
  elif [ -f "$override_context_file" ]; then
      echo "Using override file: $override_context_file. If you do not want to use one, remove the file or content."
      current_envs=$(env -i bash -c "source ${context_file} && source ${override_context_file} && env")
  else
      current_envs=$(env -i bash -c "source ${context_file} && env")
  fi
fi

added_envs=$(echo "${current_envs[@]}" | awk -F= 'NF >= 2 && $1 !~ /^BASH_FUNC_which/ { $0=$1 "=" "\"" substr($0, length($1) + 2) "\""; print }' | sort | sed 's/;/ /g')

echo -e "## This file is automatically generated by switch_context.sh\n## Do not edit it!" > "${destination_envs_file}.env"
# shellcheck disable=SC2129
echo -e "## Regenerated at $(date)\n" >> "${destination_envs_file}.env"
echo "$added_envs" >> "${destination_envs_file}.env"

# Below is a list of special cases of variables that are called the same in EVG and local context.
# This piece should probably be refactored as it's super easy to make a mistake and shadow the proper variable.
echo "workdir=\"${workdir:-.}\"" >> "${destination_envs_file}.env"

# We need to tail +5 lines due to above generated comment.
awk '{print "export " $0}' < "${destination_envs_file}".env | tail -n +5 > "${destination_envs_file}".export.env

scripts/dev/print_operator_env.sh | sort | uniq >"${destination_envs_file}.operator.env"
awk '{print "export " $0}' < "${destination_envs_file}".operator.env > "${destination_envs_file}".operator.export.env

echo "Generated env files in $(readlink -f "$destination_envs_dir"):"
ls -l1 "$destination_envs_dir"

if which kubectl > /dev/null; then
    if [ "${CLUSTER_NAME-}" ]; then
        # The convention: the cluster name must match the name of kubectl context
        # We expect this not to be true if kubernetes cluster is still to be created (minikube/kops)
        if ! kubectl config use-context "${CLUSTER_NAME}"; then
            echo "Warning: failed to switch kubectl context to: ${CLUSTER_NAME}"
            echo "Does a matching Kubernetes context exist?"
        fi

        # Setting the default namespace for current context
        kubectl config set-context "$(kubectl config current-context)" "--namespace=${NAMESPACE}" &>/dev/null || true

        # shellcheck disable=SC2153
        echo "Current context: ${CONTEXT} (kubectl context: ${CLUSTER_NAME}), namespace=${NAMESPACE}"
    fi
else
    echo "Kubectl doesn't exist, skipping setting the context"
fi

